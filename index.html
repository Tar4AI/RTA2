<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <!-- ‡∏Å‡∏±‡∏ô ‚Äú‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏≤‡∏ß‚Äù/‡∏Å‡∏¥‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà notch ‡∏ö‡∏ô iOS -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0a1120" />
  <meta name="theme-color" content="#0a1120" media="(prefers-color-scheme: dark)" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <title>Mobile RTA (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏û‡∏µ‡∏Ñ + Heatmap) ‚Äî FFT + Octave</title>

  <style>
    :root{
      --bg1:#0b1220; --bg2:#0a1120; --card:#111827; --text:#e5e7eb; --muted:#9ca3af;
      --gridH:rgba(255,255,255,0.06); --gridV:rgba(255,255,255,0.035);
      --frame:rgba(255,255,255,0.08); --label:rgba(255,255,255,0.55);
      --fft:#34d399; --peak:#a78bfa; --hold:#facc15; --bar:#34d399;
    }
    :root { color-scheme: dark; }
    html{ background:#0a1120; }
    body{
      margin:0;height:100%;
      background:radial-gradient(1200px 600px at 70% -10%, #0f1730 10%, var(--bg1) 60%, var(--bg2) 100%);
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai",sans-serif;
      -webkit-touch-callout:none; -webkit-user-select:none; user-select:none;
      overscroll-behavior:contain;
    }
    /* ‡πÄ‡∏ï‡∏¥‡∏° safe-area ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏ò‡∏µ‡∏° */
    body::before, body::after{content:"";position:fixed;left:0;right:0;z-index:9999;background:#0a1120;pointer-events:none}
    body::before{top:0;height:env(safe-area-inset-top)} body::after{bottom:0;height:env(safe-area-inset-bottom)}
    @supports (padding: env(safe-area-inset-left)) {
      html::before, html::after{content:"";position:fixed;top:0;bottom:0;background:#0a1120;z-index:9998;pointer-events:none}
      html::before{left:0;width:env(safe-area-inset-left)} html::after{right:0;width:env(safe-area-inset-right)}
    }

    .wrap{display:flex;flex-direction:column;gap:12px;max-width:920px;margin:0 auto;
      padding-left:calc(12px + env(safe-area-inset-left));
      padding-right:calc(12px + env(safe-area-inset-right));
      padding-top:calc(12px + env(safe-area-inset-top));
      padding-bottom:calc(12px + env(safe-area-inset-bottom));
    }
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:12px}
    button,select,input[type=range]{-webkit-tap-highlight-color:transparent}
    button{background:#10b981;border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:700}
    button.secondary{background:#374151} button.ghost{background:#1f2937}
    label{font-size:12px;color:var(--muted)}
    .meters{display:grid;grid-template-columns:1fr;gap:12px}
    canvas{width:100%;height:320px;background:#0b1220;border-radius:12px;touch-action:none}
    .hint{font-size:12px;color:var(--muted)}
    .kv{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .kv div{background:#0e1628;border:1px solid #1f2937;border-radius:12px;padding:8px}
    .kv b{display:block;color:#cbd5e1;font-size:12px;margin-bottom:4px}

    /* ‡∏õ‡πâ‡∏≤‡∏¢ peak/hold ‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å‡∏Å‡∏£‡∏≤‡∏ü */
    .badges{display:flex;justify-content:flex-end;gap:6px;margin:4px 0 6px 0}
    .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);font-size:12px;color:#e5e7eb;white-space:nowrap}

    /* ‡∏õ‡πâ‡∏≤‡∏¢ Hz ‡∏ï‡∏≠‡∏ô‡πÅ‡∏ï‡∏∞‡∏Ñ‡πâ‡∏≤‡∏á */
    .tip{position:absolute;padding:4px 6px;font-size:12px;color:#e5e7eb;background:rgba(0,0,0,.6);
      border:1px solid rgba(255,255,255,.12);border-radius:8px;transform:translate(-50%,-100%);pointer-events:none;white-space:nowrap}
    .plot{ position:relative; }
    .heatmapCanvas{ height: 320px; } /* Updated height to match other canvases */
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <h2 style="margin:0 0 4px 0">Mobile RTA (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏û‡∏µ‡∏Ñ + Heatmap)</h2>
          <div class="hint">‡πÅ‡∏Å‡∏ô X = Log (20 Hz ‚Üí 20 kHz) ‚Ä¢ Heatmap ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï</div>
        </div>
        <div class="row">
          <button id="btnStart">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î</button>
          <button id="btnStop" class="secondary" disabled>‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
          <button id="btnHold" class="ghost" aria-pressed="false">üìå Hold Peak: OFF</button>
          <button id="btnClear" class="secondary">‚ôªÔ∏è Clear Peak</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <label>FFT Size
          <select id="fft">
            <option value="2048">2048</option>
            <option value="4096" selected>4096</option>
            <option value="8192">8192</option>
            <option value="16384">16384</option>
          </select>
        </label>
        <label> Smoothing <input id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.75"></label>
        <label> Averaging <input id="avg" type="checkbox" checked></label>
        <label> A-weighting (‡πÄ‡∏î‡πÇ‡∏°‡πà) <input id="aWeight" type="checkbox"></label>
      </div>
      <div class="row">
        <label>‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏õ‡∏¥‡∏î DSP ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö (‡∏ö‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏¢‡∏≠‡∏°‡∏õ‡∏¥‡∏î):</label>
        <div class="row">
          <label>echoCancellation <input id="ec" type="checkbox" checked></label>
          <label>noiseSuppression <input id="ns" type="checkbox" checked></label>
          <label>autoGainControl <input id="agc" type="checkbox" checked></label>
        </div>
      </div>
    </div>
    
    <div class="meters">
      <!-- FFT -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b>RTA ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (FFT, Log Frequency)</b>
          <span class="hint" id="labelRate">‚Äî</span>
        </div>
        <div class="badges">
          <span class="badge" id="fftPeakText">Peak: ‚Äî</span>
          <span class="badge" id="fftHoldText" style="display:none;">Hold: ‚Äî</span>
        </div>
        <div class="plot">
          <canvas id="fftCanvas" width="1200" height="320"></canvas>
          <div id="fftTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <!-- OCTAVE -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b id="octTitle">RTA ‡πÅ‡∏ö‡∏ö 1/3 Octave (Log Axis)</b>
          <span class="row" style="gap:10px;align-items:center">
            <span class="hint" id="labelOct">20 Hz ‚Äì 20 kHz</span>
            <label>Octave
              <select id="octRes">
                <option value="3" selected>1/3</option>
                <option value="6">1/6</option>
              </select>
            </label>
          </span>
        </div>
        <div class="badges">
          <span class="badge" id="octPeakText">Peak: ‚Äî</span>
          <span class="badge" id="octHoldText" style="display:none;">Hold: ‚Äî</span>
        </div>
        <div class="plot">
          <canvas id="octCanvas" width="1200" height="320"></canvas>
          <div id="octTip" class="tip" style="display:none">‚Äî</div>
        </div>
      </div>

      <!-- Heatmap -->
      <div class="card" id="heatmapCard">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b>Spectrogram / Heatmap</b>
          <!-- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î-‡∏õ‡∏¥‡∏î heatmap -->
          <button id="btnToggleHeatmap" class="ghost" aria-pressed="true">üî• Heatmap: ON</button>
        </div>
        <div class="plot">
          <canvas id="heatmapCanvas" width="1200" height="320"></canvas>
        </div>
        <div class="row" style="margin-top:8px">
          <p class="hint">Heatmap Update Rate: 33 ms (Fixed)</p>
        </div>
      </div>
    </div>
    
    <div class="card kv">
      <div><b>‡∏£‡∏∞‡∏î‡∏±‡∏ö RMS (‡∏î‡∏¥‡∏ö dBFS)</b><span id="rms">‚Äî</span></div>
      <div><b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏û‡∏µ‡∏Ñ‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì</b><span id="peak">‚Äî</span></div>
    </div>

    <div class="card hint">‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î: ‡πÑ‡∏°‡∏Ñ‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡∏°‡∏µ DSP/AGC ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÑ‡∏°‡πà‡πÅ‡∏ü‡∏•‡∏ï ‡πÉ‡∏ä‡πâ‡∏î‡∏π‡πÅ‡∏ô‡∏ß EQ ‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏°‡∏≤‡∏ï‡∏£‡∏ß‡∏±‡∏î SPL ‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û</div>
  </div>

<script>
(() => {
  // ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ß‡πâ‡∏ô‡∏£‡∏≠‡∏ö Plot
  const PAD = { L: 40, R: 10, T: 10, B: 32 };
  const LABEL_Y = 10;

  // ‡∏™‡∏µ‡∏Å‡∏£‡∏¥‡∏î
  const GRID_H = getComputedStyle(document.documentElement).getPropertyValue('--gridH').trim();
  const GRID_V = getComputedStyle(document.documentElement).getPropertyValue('--gridV').trim();
  const FRAME  = getComputedStyle(document.documentElement).getPropertyValue('--frame').trim();
  const LABEL  = getComputedStyle(document.documentElement).getPropertyValue('--label').trim();

  // DOM
  const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const btnHold  = document.getElementById('btnHold');
  const btnClear = document.getElementById('btnClear');
  const btnToggleHeatmap = document.getElementById('btnToggleHeatmap');

  const fftSel   = document.getElementById('fft');
  const smoothing= document.getElementById('smoothing');
  const avgChk   = document.getElementById('avg');
  const aWeightChk = document.getElementById('aWeight');
  const ec = document.getElementById('ec');
  const ns = document.getElementById('ns');
  const agc = document.getElementById('agc');

  const fftPeakText = document.getElementById('fftPeakText');
  const fftHoldText = document.getElementById('fftHoldText');
  const octPeakText = document.getElementById('octPeakText');
  const octHoldText = document.getElementById('octHoldText');

  const fftCanvas = document.getElementById('fftCanvas');
  const octCanvas = document.getElementById('octCanvas');
  const heatmapCanvas = document.getElementById('heatmapCanvas');
  const fftTip = document.getElementById('fftTip');
  const octTip = document.getElementById('octTip');
  const ctxFFT = fftCanvas.getContext('2d');
  const ctxOct = octCanvas.getContext('2d');
  const ctxHeatmap = heatmapCanvas.getContext('2d');

  const labelRate = document.getElementById('labelRate');
  const labelOct  = document.getElementById('labelOct');
  const octTitle  = document.getElementById('octTitle');
  const rmsEl = document.getElementById('rms');
  const peakEl= document.getElementById('peak');
  const octResSel = document.getElementById('octRes');

  // Audio state
  let audioCtx, analyser, micSrc, rafId;
  let dataArray, freqArray;
  let sampleRate = 48000;
  let avgBuffer = null;
  let running = false;

  // Hold Peak
  let holdEnabled = false;
  let peakArray = null; // FFT
  let peakOct   = null; // Oct bands

  // ‡πÄ‡∏™‡πâ‡∏ô‡∏õ‡∏£‡∏∞‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏ï‡∏≠‡∏ô‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á
  let guideFFT = null;
  let guideOCT = null;

  // Octave resolution state (n=3 -> 1/3, n=6 -> 1/6)
  let octN = 3;
  let bands = []; // [{fc, fl, fh}]

  // Heatmap state
  let heatmapData = [];
  const maxHeatmapData = 200; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß‡πÉ‡∏ô‡∏Æ‡∏µ‡∏ó‡πÅ‡∏°‡∏û
  const heatmapHeight = 320; // Canvas height
  const plotHeatmapH = heatmapHeight - PAD.B;
  const heatmapFreqBins = 300; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà
  
  const HEATMAP_UPDATE_RATE_MS = 33;
  let lastHeatmapUpdate = 0;
  
  let heatmapEnabled = true;

  // ==== Helpers ====
  const dbfs = v => 20*Math.log10(v/255 + 1e-12);
  const clamp01 = v => Math.min(1, Math.max(0,v));
  function aWeighting(f){ const f2=f*f; const ra=(12200**2*f2**2)/((f2+20.6**2)*(f2+12200**2)*Math.sqrt((f2+107.7**2)*(f2+737.9**2))); return 20*Math.log10(ra)+2.0; }
  function fmtHz(f){ return f>=1000 ? ((f/1000>=10? (f/1000).toFixed(0):(f/1000).toFixed(1))+' kHz') : (Math.round(f)+' Hz'); }
  const fmax = () => Math.min(sampleRate/2, 20000);
  const fmin = 20;

  // map <-> screen
  function mapLogX(f, width){
    const fm=fmax();
    const t=(Math.log10(Math.max(f,fmin))-Math.log10(fmin))/(Math.log10(fm)-Math.log10(fmin));
    return PAD.L + t * (width - PAD.L - PAD.R);
  }
  function xToFreq(x, width){
    const fm=fmax();
    const plotW = width - PAD.L - PAD.R;
    const t = clamp01((x - PAD.L)/plotW);
    const lf = Math.log10(fmin) + t*(Math.log10(fm)-Math.log10(fmin));
    return Math.pow(10, lf);
  }
  function mapDbToY(db, height){
    const norm = clamp01((db + 100) / 100);
    const plotH = height - PAD.T - PAD.B;
    return PAD.T + (1 - norm) * plotH;
  }
  // Map dB to a color for the heatmap (blue to yellow to red)
  function mapDbToColor(db) {
    if (db < -60) {
      return '#0b1220'; // ‡∏£‡∏∞‡∏î‡∏±‡∏ö 1: ‡∏°‡∏∑‡∏î, ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö‡∏°‡∏≤‡∏Å
    } else if (db < -40) {
      return '#3b82f6'; // ‡∏£‡∏∞‡∏î‡∏±‡∏ö 2: ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô, ‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
    } else if (db < -20) {
      return '#22c55e'; // ‡∏£‡∏∞‡∏î‡∏±‡∏ö 3: ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß, ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
    } else if (db < -5) {
      return '#facc15'; // ‡∏£‡∏∞‡∏î‡∏±‡∏ö 4: ‡∏™‡∏µ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á, ‡∏î‡∏±‡∏á
    } else {
      return '#ef4444'; // ‡∏£‡∏∞‡∏î‡∏±‡∏ö 5: ‡∏™‡∏µ‡πÅ‡∏î‡∏á, ‡∏î‡∏±‡∏á‡∏°‡∏≤‡∏Å
    }
  }

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏¢‡πà‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö 1/n octave (‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏≠‡∏¥‡∏á 1 kHz)
  function genBands(n){
    const r = Math.pow(2, 1/n);                 // factor ‡∏ï‡πà‡∏≠‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏¢‡πà‡∏≤‡∏ô
    const fm = fmax();
    const kmin = Math.ceil( Math.log(fmin/1000) / Math.log(r) );
    const kmax = Math.floor( Math.log(fm/1000)   / Math.log(r) );
    const edgeHalf = Math.pow(2, 1/(2*n));      // ‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏¢‡πà‡∏≤‡∏ô

    const arr = [];
    for(let k=kmin; k<=kmax; k++){
      const fc = 1000 * Math.pow(r, k);
      const fl = fc / edgeHalf;
      const fh = fc * edgeHalf;
      if(fh < fmin || fl > fm) continue;
      arr.push({fc, fl: Math.max(fl, fmin), fh: Math.min(fh, fm)});
    }
    labelOct.textContent = `${Math.round(arr[0].fc)} Hz ‚Äì ${Math.round(arr[arr.length-1].fc)} Hz`;
    octTitle.textContent = `RTA ‡πÅ‡∏ö‡∏ö 1/${n} Octave (Log Axis)`;
    return arr;
  }

  // ==== ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á/‡∏Å‡∏£‡∏¥‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö FFT ‡πÅ‡∏•‡∏∞ Octave) ====
  function drawBackground(ctx){
    const {width:w, height:h} = ctx.canvas;
    ctx.clearRect(0,0,w,h);
    const plotH = h - PAD.T - PAD.B;

    // ‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
    ctx.strokeStyle = GRID_H;
    for(let i=0;i<6;i++){
      const y = PAD.T + (i/5) * plotH;
      ctx.beginPath(); ctx.moveTo(PAD.L,y); ctx.lineTo(w-PAD.R,y); ctx.stroke();
    }
    // ‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á log ticks
    ctx.strokeStyle = GRID_V;
    const ticks=[20,31.5,40,50,63,80,100,125,160,200,250,315,400,500,630,800,1000,2000,4000,8000,16000];
    ticks.forEach(t=>{ const x=mapLogX(t,w); ctx.beginPath(); ctx.moveTo(x,PAD.T); ctx.lineTo(x, PAD.T+plotH); ctx.stroke(); });

    // ‡∏Å‡∏£‡∏≠‡∏ö
    ctx.strokeStyle = FRAME;
    ctx.strokeRect(PAD.L, PAD.T, w-PAD.L-PAD.R, plotH);

    // ‡∏õ‡πâ‡∏≤‡∏¢‡πÅ‡∏Å‡∏ô X
    ctx.fillStyle = LABEL;
    ctx.font = '12px system-ui';
    ctx.textBaseline = 'alphabetic';
    [31.5,63,125,250,500,1000,2000,4000,8000,16000].forEach(t=>{
      const x=mapLogX(t,w);
      ctx.fillText(t>=1000?(t/1000)+'k':t, x-8, h - LABEL_Y);
    });
  }

  function drawPeakLine(ctx, x, h, color, dashed=false){
    const y0 = PAD.T, y1 = h - PAD.B;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    if(dashed) ctx.setLineDash([5,5]);
    ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y1); ctx.stroke();
    ctx.restore();
  }
  function drawGuide(ctx, x, h){
    ctx.save();
    ctx.strokeStyle = 'rgba(96,165,250,.75)'; ctx.setLineDash([4,4]);
    ctx.beginPath(); ctx.moveTo(x, PAD.T); ctx.lineTo(x, h-PAD.B); ctx.stroke();
    ctx.restore();
  }

  // ==== ‡∏ß‡∏≤‡∏î FFT ====
  function drawFFT(){
    const {width:w,height:h} = ctxFFT.canvas;
    drawBackground(ctxFFT);
    if(!freqArray) return;

    const N=freqArray.length; const fpb=sampleRate/(2*N);

    // peak (current)
    let peakBin=0, peakVal=-Infinity;
    for(let i=0;i<N;i++){ if(freqArray[i]>peakVal){ peakVal=freqArray[i]; peakBin=i; } }
    const peakFreqNow = peakBin*fpb;
    const peakDbNow = dbfs(freqArray[peakBin]||0);
    peakEl.textContent = Math.round(peakFreqNow) + ' Hz';

    if(!peakArray || peakArray.length!==N) peakArray=new Uint8Array(N);
    if(holdEnabled) for(let i=0;i<N;i++) peakArray[i] = Math.max(peakArray[i], freqArray[i]);

    // current (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß)
    ctxFFT.beginPath(); let started=false;
    for(let i=1;i<N;i++){
      const f=i*fpb; if(f<20) continue; if(f>20000) break;
      const x=mapLogX(f,w);
      const y=mapDbToY(dbfs(freqArray[i]), h);
      if(!started){ ctxFFT.moveTo(x,y); started=true; } else ctxFFT.lineTo(x,y);
    }
    ctxFFT.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--fft').trim();
    ctxFFT.lineWidth=2; ctxFFT.stroke();

    // peak-hold (‡∏°‡πà‡∏ß‡∏á ‡∏à‡∏≤‡∏á)
    ctxFFT.beginPath(); started=false;
    for(let i=1;i<N;i++){
      const f=i*fpb; if(f<20) continue; if(f>20000) break;
      const x=mapLogX(f,w);
      const y=mapDbToY(dbfs(peakArray[i]||0), h);
      if(!started){ ctxFFT.moveTo(x,y); started=true; } else ctxFFT.lineTo(x,y);
    }
    ctxFFT.save(); ctxFFT.globalAlpha=0.35; ctxFFT.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--peak').trim(); ctxFFT.lineWidth=1.25; ctxFFT.stroke(); ctxFFT.restore();

    // ‡πÄ‡∏™‡πâ‡∏ô‡∏û‡∏µ‡∏Ñ (current + hold)
    const xPeakNow = mapLogX(peakFreqNow, w);
    drawPeakLine(ctxFFT, xPeakNow, h, 'rgba(96,165,250,0.6)', false);
    let holdBin=0, holdVal=0;
    for(let i=0;i<N;i++){ if(peakArray[i]>holdVal){ holdVal=peakArray[i]; holdBin=i; } }
    if(holdVal>0){ drawPeakLine(ctxFFT, mapLogX(holdBin*fpb, w), h, 'rgba(250,204,21,0.55)', true); }

    // ‡∏õ‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏≤‡∏ô‡∏ô‡∏≠‡∏Å‡∏Å‡∏£‡∏≤‡∏ü
    fftPeakText.textContent = `Peak: ${fmtHz(peakFreqNow)} ‚Ä¢ ${peakDbNow.toFixed(1)} dBFS`;
    if(holdVal>0){ fftHoldText.style.display=''; fftHoldText.textContent = `Hold: ${fmtHz(holdBin*fpb)} ‚Ä¢ ${dbfs(holdVal).toFixed(1)} dBFS`; }
    else { fftHoldText.style.display='none'; }

    if(guideFFT){ drawGuide(ctxFFT, guideFFT.xPx, h); }
  }

  // ==== ‡∏ß‡∏≤‡∏î Octave ====
  function drawOctave(){
    const {width:w,height:h} = ctxOct.canvas;
    drawBackground(ctxOct);
    if(!freqArray || !bands.length) return;

    const N=freqArray.length; const fpb=sampleRate/(2*N);

    const vals = bands.map(b=>{
      const s=Math.max(0,Math.floor(b.fl/fpb)), e=Math.min(N-1,Math.ceil(b.fh/fpb));
      let sum=0,cnt=0; for(let i=s;i<=e;i++){ sum+=freqArray[i]; cnt++; }
      let v=cnt?(sum/cnt):0;
      if(aWeightChk.checked) v*=Math.pow(10, aWeighting(b.fc)/20);
      return v;
    });

    if(!peakOct || peakOct.length!==vals.length) peakOct=new Float32Array(vals.length);
    if(holdEnabled) for(let i=0;i<vals.length;i++) peakOct[i]=Math.max(peakOct[i], vals[i]);

    // ‡πÅ‡∏ó‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß)
    ctxOct.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--bar').trim();
    for(let i=0;i<vals.length;i++){
      const b=bands[i];
      const xL=mapLogX(b.fl,w), xR=mapLogX(b.fh,w);
      const barW=Math.max(2, xR-xL-2);
      const y=mapDbToY(dbfs(vals[i]), h);
      const plotBottom=h-PAD.B;
      const hh=(plotBottom - y);
      ctxOct.fillRect(xL+1, y, barW, Math.max(1, hh));
    }

    // ‡πÄ‡∏™‡πâ‡∏ô‡πÇ‡∏Æ‡∏•‡∏î‡πå‡πÅ‡∏ö‡∏ö‡∏à‡∏≤‡∏á
    ctxOct.beginPath();
    for(let i=0;i<vals.length;i++){
      const cx=mapLogX(bands[i].fc,w);
      const y=mapDbToY(dbfs(peakOct[i]||0), h);
      if(i===0) ctxOct.moveTo(cx,y); else ctxOct.lineTo(cx,y);
    }
    ctxOct.save(); ctxOct.globalAlpha=0.45; ctxOct.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--hold').trim(); ctxOct.lineWidth=1.5; ctxOct.stroke(); ctxOct.restore();

    // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏û‡∏µ‡∏Ñ (current + hold)
    let idxNow=0, vNow=-1;
    for(let i=0;i<vals.length;i++){ if(vals[i]>vNow){ vNow=vals[i]; idxNow=i; } }
    drawPeakLine(ctxOct, mapLogX(bands[idxNow].fc,w), h, 'rgba(96,165,250,0.6)', false);

    let idxHold=0, vHold=0;
    for(let i=0;i<peakOct.length;i++){ if(peakOct[i]>vHold){ vHold=peakOct[i]; idxHold=i; } }
    if(vHold>0){ drawPeakLine(ctxOct, mapLogX(bands[idxHold].fc,w), h, 'rgba(250,204,21,0.55)', true); }

    // ‡∏õ‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏≤‡∏ô‡∏ô‡∏≠‡∏Å‡∏Å‡∏£‡∏≤‡∏ü
    octPeakText.textContent = `Peak: ${fmtHz(bands[idxNow].fc)} ‚Ä¢ ${dbfs(vNow).toFixed(1)} dBFS`;
    if(vHold>0){ octHoldText.style.display=''; octHoldText.textContent = `Hold: ${fmtHz(bands[idxHold].fc)} ‚Ä¢ ${dbfs(vHold).toFixed(1)} dBFS`; }
    else { octHoldText.style.display='none'; }

    if(guideOCT){ drawGuide(ctxOct, guideOCT.xPx, h); }
  }

  // ==== ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á/‡∏Å‡∏£‡∏¥‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Heatmap) ====
  function drawHeatmapBackground(ctx) {
    const {width:w} = ctx.canvas;

    // ‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á log ticks
    ctx.strokeStyle = GRID_V;
    const ticks=[20,31.5,40,50,63,80,100,125,160,200,250,315,400,500,630,800,1000,2000,4000,8000,16000];
    ticks.forEach(t=>{ const x=mapLogX(t,w); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, heatmapHeight - PAD.B); ctx.stroke(); });

    // ‡∏õ‡πâ‡∏≤‡∏¢‡πÅ‡∏Å‡∏ô X
    ctx.fillStyle = LABEL;
    ctx.font = '12px system-ui';
    ctx.textBaseline = 'alphabetic';
    [31.5,63,125,250,500,1000,2000,4000,8000,16000].forEach(t=>{
      const x=mapLogX(t,w);
      ctx.fillText(t>=1000?(t/1000)+'k':t, x-8, heatmapHeight - LABEL_Y);
    });
  }

  // ==== ‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏±‡∏ö‡∏ö‡∏ô Canvas ====
  function drawOverlayMessage() {
    const {width:w, height:h} = ctxHeatmap.canvas;
    ctxHeatmap.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctxHeatmap.font = '24px system-ui';
    ctxHeatmap.textAlign = 'center';
    ctxHeatmap.textBaseline = 'middle';
    ctxHeatmap.fillText('Heatmap OFF', w/2, h/2);
  }

  // ==== ‡∏ß‡∏≤‡∏î Heatmap ====
  function drawHeatmap() {
    const {width:w} = ctxHeatmap.canvas;
    const fmaxVal = fmax();
    const fpb = sampleRate / analyser.fftSize;

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ñ‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
    const currentData = [];
    const logFmin = Math.log10(fmin);
    const logFmax = Math.log10(fmaxVal);
    
    for (let i = 0; i < heatmapFreqBins; i++) {
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ö‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏ö‡∏ö Logarithmic
        const logFStart = logFmin + (i / heatmapFreqBins) * (logFmax - logFmin);
        const logFEnd = logFmin + ((i + 1) / heatmapFreqBins) * (logFmax - logFmin);
        const fStart = Math.pow(10, logFStart);
        const fEnd = Math.pow(10, logFEnd);

        // ‡∏´‡∏≤ bin ‡πÉ‡∏ô array ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ä‡πà‡∏ß‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏ô‡∏µ‡πâ
        const binStart = Math.max(0, Math.floor(fStart / fpb));
        const binEnd = Math.min(analyser.frequencyBinCount - 1, Math.ceil(fEnd / fpb));

        let sum = 0;
        let count = 0;
        for (let j = binStart; j <= binEnd; j++) {
            sum += freqArray[j];
            count++;
        }
        
        const avgDb = count > 0 ? dbfs(sum / count) : -100;
        
        currentData.push({
            freqStart: fStart,
            freqEnd: fEnd,
            db: avgDb
        });
    }

    heatmapData.unshift(currentData);
    if (heatmapData.length > maxHeatmapData) {
        heatmapData.pop();
    }

    ctxHeatmap.clearRect(0, 0, w, heatmapHeight);
    
    const timeScale = plotHeatmapH / maxHeatmapData;

    // ‡∏ß‡∏≤‡∏î heatmap
    for (let i = 0; i < heatmapData.length; i++) {
      const y = i * timeScale;
      const frameData = heatmapData[i];
      for (let j = 0; j < frameData.length; j++) {
        const { freqStart, freqEnd, db } = frameData[j];
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÅ‡∏•‡∏∞‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á bar ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ logarithmic scale
        const xL = mapLogX(freqStart, w);
        const xR = mapLogX(freqEnd, w);
        const barWidth = Math.max(1, xR - xL);

        ctxHeatmap.fillStyle = mapDbToColor(db);
        ctxHeatmap.fillRect(xL, y, barWidth, timeScale);
      }
    }
    
    // ‡∏ß‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡πâ‡∏≤‡∏¢‡∏Å‡∏≥‡∏Å‡∏±‡∏ö
    drawHeatmapBackground(ctxHeatmap);
  }

  // ==== RMS ====
  function updateRMS(){
    if(!dataArray) return;
    let sum=0; for(let i=0;i<dataArray.length;i++){ const v=(dataArray[i]-128)/128; sum+=v*v; }
    const rms=Math.sqrt(sum/dataArray.length);
    const db=20*Math.log10(rms+1e-12);
    rmsEl.textContent = db.toFixed(1)+' dBFS';
  }

  function loop(){
    if(!running) return;

    // Update FFT, Octave, and RMS on every frame
    analyser.getByteTimeDomainData(dataArray);
    analyser.getByteFrequencyData(freqArray);
    if(avgChk.checked){
      if(!avgBuffer || avgBuffer.length!==freqArray.length) avgBuffer=new Float32Array(freqArray.length);
      const alpha=0.5;
      for(let i=0;i<freqArray.length;i++){
        avgBuffer[i]=alpha*avgBuffer[i]+(1-alpha)*freqArray[i];
        freqArray[i]=avgBuffer[i];
      }
    }
    drawFFT();
    drawOctave();
    updateRMS();

    // Only update heatmap if the interval has passed AND heatmap is enabled
    const now = performance.now();
    if(heatmapEnabled && (now - lastHeatmapUpdate >= HEATMAP_UPDATE_RATE_MS)){
        drawHeatmap(); 
        lastHeatmapUpdate = now;
    }

    rafId=requestAnimationFrame(loop);
  }

  async function start(){
    try{
      btnStart.disabled=true; btnStop.disabled=false;
      const constraints={ audio:{ echoCancellation: ec.checked? false:true, noiseSuppression: ns.checked? false:true, autoGainControl: agc.checked? false:true } };
      const stream=await navigator.mediaDevices.getUserMedia(constraints);
      audioCtx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
      if(audioCtx.state==='suspended') await audioCtx.resume();

      sampleRate=audioCtx.sampleRate;
      labelRate.textContent = `${Math.round(sampleRate)} Hz`;

      analyser=audioCtx.createAnalyser();
      analyser.fftSize=parseInt(fftSel.value,10);
      analyser.smoothingTimeConstant=parseFloat(smoothing.value);

      micSrc=audioCtx.createMediaStreamSource(stream);
      micSrc.connect(analyser);

      dataArray=new Uint8Array(analyser.fftSize);
      freqArray=new Uint8Array(analyser.frequencyBinCount);
      peakArray=new Uint8Array(analyser.frequencyBinCount);

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏¢‡πà‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
      bands = genBands(octN);
      peakOct = new Float32Array(bands.length);

      heatmapData = []; // Clear heatmap on start
      lastHeatmapUpdate = 0;
      running=true; loop();
    }catch(err){
      // Use a custom modal or message box instead of alert()
      console.error('‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡πÇ‡∏ü‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: '+(err.message||err));
      // You could display an error message on the page here
      btnStart.disabled=false; btnStop.disabled=true;
    }
  }
  function stop(){
    running=false; if(rafId) cancelAnimationFrame(rafId);
    try{micSrc&&micSrc.disconnect();}catch{} try{analyser&&analyser.disconnect();}catch{}
    if(audioCtx){audioCtx.close();}
    btnStart.disabled=false; btnStop.disabled=true;
  }

  // ‡πÅ‡∏ï‡∏∞‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏™‡πâ‡∏ô‡∏õ‡∏£‡∏∞+‡∏õ‡πâ‡∏≤‡∏¢ Hz
  function attachPressGuide(canvas, tipEl, which){
    let pressed=false;
    const getX = (e) => {
      const rect = canvas.getBoundingClientRect();
      const xCss = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
      // scale CSS px -> canvas px
      return Math.max(PAD.L, Math.min(canvas.width-PAD.R, xCss * (canvas.width/rect.width)));
    };
    const update = (xPx) => {
      const freq = xToFreq(xPx, canvas.width);
      const plot = canvas.parentElement.getBoundingClientRect();
      tipEl.style.display='block';
      tipEl.textContent = fmtHz(freq);
      const cssX = (xPx / canvas.width) * plot.width;
      tipEl.style.left = cssX + 'px';
      tipEl.style.top  = '8px';
      if(which==='fft') guideFFT = {xPx, freq}; else guideOCT = {xPx, freq};
    };
    const clear = () => { tipEl.style.display='none'; if(which==='fft') guideFFT=null; else guideOCT=null; };

    const onDown = (e)=>{ pressed=true; e.preventDefault(); update(getX(e)); };
    const onMove = (e)=>{ if(!pressed) return; e.preventDefault(); update(getX(e)); };
    const onUp   = (_)=>{ pressed=false; clear(); };

    canvas.addEventListener('touchstart', onDown, {passive:false});
    canvas.addEventListener('touchmove',  onMove,  {passive:false});
    canvas.addEventListener('touchend',   onUp,    {passive:true});
    canvas.addEventListener('mousedown',  onDown);
    window.addEventListener('mousemove',  onMove);
    window.addEventListener('mouseup',    onUp);
    canvas.addEventListener('contextmenu', e=>e.preventDefault());
  }
  attachPressGuide(fftCanvas, fftTip, 'fft');
  attachPressGuide(octCanvas, octTip, 'oct');

  // Events
  btnStart.addEventListener('click', start, {passive:true});
  btnStop .addEventListener('click', stop , {passive:true});
  btnHold .addEventListener('click', ()=>{
    holdEnabled=!holdEnabled;
    btnHold.setAttribute('aria-pressed', String(holdEnabled));
    btnHold.textContent = holdEnabled ? 'üìå Hold Peak: ON' : 'üìå Hold Peak: OFF';
  }, {passive:true});
  
  // Update the clear button event to also clear the heatmap
  btnClear.addEventListener('click', ()=>{
    if(peakArray) peakArray.fill(0);
    if(peakOct)   peakOct.fill(0);
    heatmapData = [];
    if (!heatmapEnabled) {
      ctxHeatmap.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
      drawHeatmapBackground(ctxHeatmap);
      drawOverlayMessage();
    }
  }, {passive:true});

  // Event for the new heatmap toggle button
  btnToggleHeatmap.addEventListener('click', ()=>{
    heatmapEnabled = !heatmapEnabled;
    btnToggleHeatmap.setAttribute('aria-pressed', String(heatmapEnabled));
    btnToggleHeatmap.textContent = heatmapEnabled ? 'üî• Heatmap: ON' : 'üî• Heatmap: OFF';
    
    // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î heatmap ‡πÉ‡∏´‡πâ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå canvas ‡πÅ‡∏•‡∏∞‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà
    if (!heatmapEnabled) {
      ctxHeatmap.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
      drawHeatmapBackground(ctxHeatmap);
      drawOverlayMessage();
    } else {
      // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÉ‡∏´‡πâ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå canvas ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ loop ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏≤‡∏î‡πÉ‡∏´‡∏°‡πà
      ctxHeatmap.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
    }
  }, {passive:true});
  
  fftSel.addEventListener('change', ()=>{
    if(!analyser) return;
    analyser.fftSize=parseInt(fftSel.value,10);
    dataArray=new Uint8Array(analyser.fftSize);
    freqArray=new Uint8Array(analyser.frequencyBinCount);
    peakArray=new Uint8Array(analyser.frequencyBinCount);
    // ‡∏£‡∏µ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏¢‡πà‡∏≤‡∏ô‡∏ï‡∏≤‡∏° octN ‡πÄ‡∏î‡∏¥‡∏°
    bands = genBands(octN);
    peakOct = new Float32Array(bands.length);
  });
  smoothing.addEventListener('input', ()=>{ if(analyser) analyser.smoothingTimeConstant=parseFloat(smoothing.value); });

  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÇ‡∏´‡∏°‡∏î 1/3 ‚Üî 1/6
  octResSel.addEventListener('change', ()=>{
    octN = parseInt(octResSel.value,10);         // 3 ‡∏´‡∏£‡∏∑‡∏≠ 6
    bands = genBands(octN);
    peakOct = new Float32Array(bands.length);    // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï hold
  });

  // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï select/‡πÇ‡∏ü‡∏Å‡∏±‡∏™‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ó‡∏£‡∏• (‡∏Å‡∏±‡∏ô‡πÑ‡∏Æ‡πÑ‡∏•‡∏ï‡πå‡∏ï‡∏≠‡∏ô‡∏•‡∏≤‡∏Å‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠)
  ['input','select','button','label'].forEach(sel=>{
    document.querySelectorAll(sel).forEach(el=>{
      el.style.webkitUserSelect='auto'; el.style.userSelect='auto';
    });
  });
})();
</script>
</body>
</html>
