<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="utf-8" />
    <!-- ‡∏Å‡∏±‡∏ô ‚Äú‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏≤‡∏ß‚Äù/‡∏Å‡∏¥‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà notch ‡∏ö‡∏ô iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
    <meta name="theme-color" content="#0a1120" />
    <meta name="theme-color" content="#0a1120" media="(prefers-color-scheme: dark)" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Mobile RTA </title>

    <style>
        :root {
            --bg1:#0b1220; --bg2:#0a1120; --card:#111827; --text:#e5e7eb; --muted:#9ca3af;
            --gridH:rgba(255,255,255,0.06); --gridV:rgba(255,255,255,0.035);
            --frame:rgba(255,255,255,0.08); --label:rgba(255,255,255,0.55);
            --fft:#34d399; --peak:#a78bfa; --hold:#facc15; --bar:#34d399;
            --heatmap-color-1:#0b1220; --heatmap-color-2:#3b82f6; --heatmap-color-3:#22c55e;
            --heatmap-color-4:#facc15; --heatmap-color-5:#ef4444;
        }
        :root { color-scheme: dark; }
        html{ background:#0a1120; }
        body{
            margin:0; height:100%;
            background:radial-gradient(1200px 600px at 70% -10%, #0f1730 10%, var(--bg1) 60%, var(--bg2) 100%);
            color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai",sans-serif;
            -webkit-touch-callout:none; -webkit-user-select:none; user-select:none;
            overscroll-behavior:contain;
        }
        /* ‡πÄ‡∏ï‡∏¥‡∏° safe-area ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏ò‡∏µ‡∏° */
        body::before, body::after{content:"";position:fixed;left:0;right:0;z-index:9999;background:#0a1120;pointer-events:none}
        body::before{top:0;height:env(safe-area-inset-top)} body::after{bottom:0;height:env(safe-area-inset-bottom)}
        @supports (padding: env(safe-area-inset-left)) {
            html::before, html::after{content:"";position:fixed;top:0;bottom:0;background:#0a1120;z-index:9998;pointer-events:none}
            html::before{left:0;width:env(safe-area-inset-left)} html::after{right:0;width:env(safe-area-inset-right)}
        }

        .wrap{
            display:flex; flex-direction:column; gap:12px; max-width:920px; margin:0 auto;
            padding-left:calc(12px + env(safe-area-inset-left));
            padding-right:calc(12px + env(safe-area-inset-right));
            padding-top:calc(12px + env(safe-area-inset-top));
            padding-bottom:calc(12px + env(safe-area-inset-bottom));
        }
        .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
        .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:12px}
        button,select,input[type=range]{-webkit-tap-highlight-color:transparent}
        button{background:#10b981;border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
        button.secondary{background:#374151} button.ghost{background:#1f2937}
        label{font-size:12px;color:var(--muted)}
        .meters{display:grid;grid-template-columns:1fr;gap:12px}
        canvas{width:100%;height:320px;background:#0b1220;border-radius:12px;touch-action:none}
        .hint{font-size:12px;color:var(--muted)}
        .kv{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
        .kv div{background:#0e1628;border:1px solid #1f2937;border-radius:12px;padding:8px}
        .kv b{display:block;color:#cbd5e1;font-size:12px;margin-bottom:4px}
        .badges{display:flex;justify-content:flex-end;gap:6px;margin:4px 0 6px 0}
        .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);font-size:12px;color:#e5e7eb;white-space:nowrap}
        .tip{
            position:absolute; padding:4px 6px; font-size:12px; color:#e5e7eb;
            background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.12);
            border-radius:8px; transform:translate(-50%,-100%); pointer-events:none;
            white-space:nowrap; z-index: 10;
        }
        .plot{ position:relative; }
    </style>
</head>
<body>
    <div class="wrap">
        <div class="card">
            <div class="row" style="justify-content:space-between">
                <div>
                    <h2 style="margin:0 0 4px 0">Mobile RTA  </h2>
                    <div class="hint">‡πÅ‡∏Å‡∏ô X = Log (20 Hz ‚Üí 20 kHz) ‚Ä¢ Heatmap ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï</div>
                </div>
                <div class="row">
                    <button id="btnStart">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î</button>
                    <button id="btnStop" class="secondary" disabled>‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
                    <button id="btnHold" class="ghost" aria-pressed="false">üìå Hold Peak: OFF</button>
                    <button id="btnClear" class="secondary">‚ôªÔ∏è Clear Peak</button>
                    <button id="btnClearDb" class="secondary">üîÑ Clear DB</button>
                </div>
            </div>
            <div class="row" style="margin-top:8px">
                <label>FFT Size
                    <select id="fft">
                        <option value="2048">2048</option>
                        <option value="4096" selected>4096</option>
                        <option value="8192">8192</option>
                        <option value="16384">16384</option>
                    </select>
                </label>
                <label> Smoothing <input id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.75"></label>
                <label> Averaging <input id="avg" type="checkbox" checked></label>
                <label> A-weighting (‡πÄ‡∏î‡πÇ‡∏°‡πà) <input id="aWeight" type="checkbox"></label>
            </div>
            <div class="row">
                <label>‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏õ‡∏¥‡∏î DSP ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö (‡∏ö‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏¢‡∏≠‡∏°‡∏õ‡∏¥‡∏î):</label>
                <div class="row">
                    <label>echoCancellation <input id="ec" type="checkbox" checked></label>
                    <label>noiseSuppression <input id="ns" type="checkbox" checked></label>
                    <label>autoGainControl <input id="agc" type="checkbox" checked></label>
                </div>
            </div>
        </div>

        <div class="meters">
            <!-- FFT -->
            <div class="card">
                <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
                    <b>RTA ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (FFT, Log Frequency)</b>
                    <span class="hint" id="labelRate">‚Äî</span>
                </div>
                <div class="badges">
                    <span class="badge" id="fftPeakText">Peak: ‚Äî</span>
                    <span class="badge" id="fftHoldText" style="display:none;">Hold: ‚Äî</span>
                </div>
                <div class="plot">
                    <canvas id="fftCanvas" width="1200" height="320"></canvas>
                    <div id="fftTip" class="tip" style="display:none">‚Äî</div>
                </div>
            </div>

            <!-- OCTAVE -->
            <div class="card">
                <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
                    <b id="octTitle">RTA ‡πÅ‡∏ö‡∏ö 1/6 Octave (Linear 0-255)</b>
                    <span class="row" style="gap:10px;align-items:center">
                        <span class="hint" id="labelOct">20 Hz ‚Äì 20 kHz</span>
                        <label>Octave
                            <select id="octRes">
                                <option value="3">1/3</option>
                                <option value="6" selected>1/6</option>
                            </select>
                        </label>
                        <!-- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡∏ô Y -->
                        <label>Y-Axis
                            <select id="yAxis">
                                <option value="linear-255" selected>Linear (0-255)</option>
                                <option value="linear-127">Linear (0-127)</option>
                                <option value="octave-db">Octave (dB)</option>
                            </select>
                        </label>
                    </span>
                </div>
                <div class="badges">
                    <span class="badge" id="octPeakText">Peak: ‚Äî</span>
                    <span class="badge" id="octHoldText" style="display:none;">Hold: ‚Äî</span>
                </div>
                <div class="plot">
                    <canvas id="octCanvas" width="1200" height="320"></canvas>
                    <div id="octTip" class="tip" style="display:none">‚Äî</div>
                </div>
            </div>

            <!-- Heatmap -->
            <div class="card" id="heatmapCard">
                <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
                    <b>Spectrogram / Heatmap</b>
                    <button id="btnToggleHeatmap" class="ghost" aria-pressed="true">üî• Heatmap: ON</button>
                </div>
                <div class="plot">
                    <canvas id="heatmapCanvas" width="1200" height="320"></canvas>
                    <div id="heatmapTip" class="tip" style="display:none">‚Äî</div>
                </div>
            </div>
        </div>

        <div class="card kv">
            <div><b>‡∏£‡∏∞‡∏î‡∏±‡∏ö RMS (‡∏î‡∏¥‡∏ö dBFS)</b><span id="rms">‚Äî</span></div>
            <div><b>DB-A Max</b><span id="maxDbEl">‚Äî</span></div>
            <div><b>DB-A Avg</b><span id="avgDbEl">‚Äî</span></div>
            <div><b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏û‡∏µ‡∏Ñ‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì</b><span id="peak">‚Äî</span></div>
        </div>
        
        <div class="card hint">‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î: ‡πÑ‡∏°‡∏Ñ‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡∏°‡∏µ DSP/AGC ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÑ‡∏°‡πà‡πÅ‡∏ü‡∏•‡∏ï ‡πÉ‡∏ä‡πâ‡∏î‡∏π‡πÅ‡∏ô‡∏ß EQ ‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏°‡∏≤‡∏ï‡∏£‡∏ß‡∏±‡∏î SPL ‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û</div>
    </div>

    <script>
        (() => {
            // ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ß‡πâ‡∏ô‡∏£‡∏≠‡∏ö Plot
            const PAD = { L: 40, R: 10, T: 10, B: 32 };
            const LABEL_Y = 10;
            const heatmapCanvasHeight = 320;

            // ‡∏™‡∏µ‡∏Å‡∏£‡∏¥‡∏î‡∏à‡∏≤‡∏Å CSS variables
            const getStyle = (prop) => getComputedStyle(document.documentElement).getPropertyValue(prop).trim();
            const GRID_H = getStyle('--gridH');
            const GRID_V = getStyle('--gridV');
            const FRAME  = getStyle('--frame');
            const LABEL  = getStyle('--label');
            const FFT_COLOR = getStyle('--fft');
            const PEAK_COLOR = getStyle('--peak');
            const HOLD_COLOR = getStyle('--hold');
            const BAR_COLOR = getStyle('--bar');

            // DOM
            const btnStart = document.getElementById('btnStart');
            const btnStop  = document.getElementById('btnStop');
            const btnHold  = document.getElementById('btnHold');
            const btnClear = document.getElementById('btnClear');
            const btnClearDb = document.getElementById('btnClearDb'); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏° Clear DB
            const btnToggleHeatmap = document.getElementById('btnToggleHeatmap');
            const fftSel   = document.getElementById('fft');
            const smoothing= document.getElementById('smoothing');
            const avgChk   = document.getElementById('avg');
            const aWeightChk = document.getElementById('aWeight');
            const ec = document.getElementById('ec');
            const ns = document.getElementById('ns');
            const agc = document.getElementById('agc');
            const fftPeakText = document.getElementById('fftPeakText');
            const fftHoldText = document.getElementById('fftHoldText');
            const octPeakText = document.getElementById('octPeakText');
            const octHoldText = document.getElementById('octHoldText');
            const fftCanvas = document.getElementById('fftCanvas');
            const octCanvas = document.getElementById('octCanvas');
            const heatmapCanvas = document.getElementById('heatmapCanvas');
            const fftTip = document.getElementById('fftTip');
            const octTip = document.getElementById('octTip');
            const heatmapTip = document.getElementById('heatmapTip');
            const ctxFFT = fftCanvas.getContext('2d');
            const ctxOct = octCanvas.getContext('2d');
            const ctxHeatmap = heatmapCanvas.getContext('2d');
            const labelRate = document.getElementById('labelRate');
            const labelOct  = document.getElementById('labelOct');
            const octTitle  = document.getElementById('octTitle');
            const rmsEl = document.getElementById('rms');
            const peakEl = document.getElementById('peak');
            const octResSel = document.getElementById('octRes');
            const yAxisSel = document.getElementById('yAxis');

            // ‡πÄ‡∏û‡∏¥‡πà‡∏° DOM ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö DB Max / Avg
            const maxDbEl = document.getElementById('maxDbEl');
            const avgDbEl = document.getElementById('avgDbEl');


            // Audio state
            let audioCtx, analyser, micSrc, rafId;
            let dataArray, freqArray;
            let sampleRate = 48000;
            let avgBuffer = null;
            let running = false;
            let holdEnabled = false;
            let peakArray = null;
            let peakOct   = null;
            let guideFFT = null;
            let guideOCT = null;
            let guideHeatmap = null;
            let octN = 6; // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô 1/6
            let bands = []; // [{fc, fl, fh}]
            let yAxisMode = 'linear-255'; // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô linear-255

            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö DB Max / Avg
            let maxDb = -120;
            let avgDb = -120;
            const avgAlpha = 0.95; // Smoothing factor ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢

            // Heatmap state
            let heatmapData = [];
            const maxHeatmapData = 200;
            const heatmapFreqBins = 300;
            const HEATMAP_UPDATE_RATE_MS = 33;
            let lastHeatmapUpdate = 0;
            let heatmapEnabled = true;
            let heatmapFreqBinMap = null; // Pre-calculated bins for heatmap

            // ==== Helpers ====
            const dbfs = v => 20 * Math.log10(v / 255 + 1e-12);
            const clamp01 = v => Math.min(1, Math.max(0, v));
            function aWeighting(f){ const f2=f*f; const ra=(12200**2*f2**2)/((f2+20.6**2)*(f2+12200**2)*Math.sqrt((f2+107.7**2)*(f2+737.9**2))); return 20*Math.log10(ra)+2.0; }
            function fmtHz(f){ return f>=1000 ? ((f/1000>=10? (f/1000).toFixed(0):(f/1000).toFixed(1))+' kHz') : (Math.round(f)+' Hz'); }
            const fmax = () => Math.min(sampleRate / 2, 20000);
            const fmin = 20;

            // map <-> screen
            function mapLogX(f, width) {
                const fm = fmax();
                const t = (Math.log10(Math.max(f, fmin)) - Math.log10(fmin)) / (Math.log10(fm) - Math.log10(fmin));
                return PAD.L + t * (width - PAD.L - PAD.R);
            }
            function xToFreq(x, width) {
                const fm = fmax();
                const plotW = width - PAD.L - PAD.R;
                const t = clamp01((x - PAD.L) / plotW);
                const lf = Math.log10(fmin) + t * (Math.log10(fm) - Math.log10(fmin));
                return Math.pow(10, lf);
            }
            // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö dBFS
            function mapDbToY(db, height) {
                const norm = clamp01((db + 100) / 100);
                const plotH = height - PAD.T - PAD.B;
                return PAD.T + (1 - norm) * plotH;
            }
            // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Linear scale
            function mapLinearToY(v, height, maxVal) {
                const norm = clamp01(v / maxVal);
                const plotH = height - PAD.T - PAD.B;
                return PAD.T + (1 - norm) * plotH;
            }

            function mapDbToColor(db) {
                if (db < -60) return getStyle('--heatmap-color-1');
                if (db < -40) return getStyle('--heatmap-color-2');
                if (db < -20) return getStyle('--heatmap-color-3');
                if (db < -5) return getStyle('--heatmap-color-4');
                return getStyle('--heatmap-color-5');
            }

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏¢‡πà‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö 1/n octave (‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏≠‡∏¥‡∏á 1 kHz)
            function genBands(n) {
                const r = Math.pow(2, 1 / n);
                const fm = fmax();
                const kmin = Math.ceil(Math.log(fmin / 1000) / Math.log(r));
                const kmax = Math.floor(Math.log(fm / 1000) / Math.log(r));
                const edgeHalf = Math.pow(2, 1 / (2 * n));
                const arr = [];
                for (let k = kmin; k <= kmax; k++) {
                    const fc = 1000 * Math.pow(r, k);
                    const fl = fc / edgeHalf;
                    const fh = fc * edgeHalf;
                    if (fh < fmin || fl > fm) continue;
                    arr.push({ fc, fl: Math.max(fl, fmin), fh: Math.min(fh, fm) });
                }
                labelOct.textContent = `${Math.round(arr[0].fc)} Hz ‚Äì ${Math.round(arr[arr.length - 1].fc)} Hz`;
                updateOctaveTitle();
                return arr;
            }
            
            function updateOctaveTitle() {
                let title = `RTA ‡πÅ‡∏ö‡∏ö 1/${octN} Octave`;
                switch(yAxisMode) {
                    case 'linear-255':
                        title += ' (Linear 0-255)';
                        break;
                    case 'linear-127':
                        title += ' (Linear 0-127)';
                        break;
                    case 'octave-db':
                        title += ' (Log Axis)';
                        break;
                }
                octTitle.textContent = title;
            }

            // Pre-calculate heatmap bins for efficiency
            function genHeatmapBins() {
                const fm = fmax();
                const fpb = sampleRate / analyser.fftSize;
                const logFmin = Math.log10(fmin);
                const logFmax = Math.log10(fm);
                const bins = [];
                for (let i = 0; i < heatmapFreqBins; i++) {
                    const logFStart = logFmin + (i / heatmapFreqBins) * (logFmax - logFmin);
                    const logFEnd = logFmin + ((i + 1) / heatmapFreqBins) * (logFmax - logFmin);
                    const fStart = Math.pow(10, logFStart);
                    const fEnd = Math.pow(10, logFEnd);
                    const binStart = Math.max(0, Math.floor(fStart / fpb));
                    const binEnd = Math.min(analyser.frequencyBinCount - 1, Math.ceil(fEnd / fpb));
                    bins.push({ binStart, binEnd, fStart, fEnd });
                }
                return bins;
            }

            // ==== ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á/‡∏Å‡∏£‡∏¥‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö FFT ‡πÅ‡∏•‡∏∞ Octave) ====
            function drawBackground(ctx, yAxisType = 'octave-db') {
                const {width: w, height: h} = ctx.canvas;
                ctx.clearRect(0, 0, w, h);
                const plotH = h - PAD.T - PAD.B;

                // ‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
                ctx.strokeStyle = GRID_H;
                let yLabels = [];
                if (yAxisType === 'octave-db') {
                    for (let i = 0; i < 6; i++) {
                        const y = PAD.T + (i / 5) * plotH;
                        ctx.beginPath(); ctx.moveTo(PAD.L, y); ctx.lineTo(w - PAD.R, y); ctx.stroke();
                    }
                    yLabels = [-100, -80, -60, -40, -20, 0];
                } else { // Linear
                    const maxVal = yAxisType === 'linear-255' ? 255 : 127;
                    for (let i = 0; i < 6; i++) {
                        const y = PAD.T + (i / 5) * plotH;
                        ctx.beginPath(); ctx.moveTo(PAD.L, y); ctx.lineTo(w - PAD.R, y); ctx.stroke();
                    }
                    yLabels = [0, maxVal/5, (maxVal/5)*2, (maxVal/5)*3, (maxVal/5)*4, maxVal];
                }

                // ‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á log ticks
                ctx.strokeStyle = GRID_V;
                const ticks = [20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
                ticks.forEach(t => {
                    const x = mapLogX(t, w);
                    ctx.beginPath(); ctx.moveTo(x, PAD.T); ctx.lineTo(x, PAD.T + plotH); ctx.stroke();
                });

                // ‡∏Å‡∏£‡∏≠‡∏ö
                ctx.strokeStyle = FRAME;
                ctx.strokeRect(PAD.L, PAD.T, w - PAD.L - PAD.R, plotH);

                // ‡∏õ‡πâ‡∏≤‡∏¢‡πÅ‡∏Å‡∏ô X
                ctx.fillStyle = LABEL;
                ctx.font = '12px system-ui';
                ctx.textBaseline = 'alphabetic';
                [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000].forEach(t => {
                    const x = mapLogX(t, w);
                    ctx.fillText(t >= 1000 ? (t / 1000) + 'k' : t, x - 8, h - LABEL_Y);
                });

                // ‡∏õ‡πâ‡∏≤‡∏¢‡πÅ‡∏Å‡∏ô Y (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡πÇ‡∏´‡∏°‡∏î)
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                if (yAxisType === 'octave-db') {
                    const yLabelsDb = [-100, -80, -60, -40, -20, 0];
                    yLabelsDb.forEach((label, i) => {
                        const y = PAD.T + (i / 5) * plotH;
                        ctx.fillText(label, PAD.L - 5, y);
                    });
                } else {
                    const maxVal = yAxisType === 'linear-255' ? 255 : 127;
                    const yLabelsLinear = [maxVal, (maxVal/5)*4, (maxVal/5)*3, (maxVal/5)*2, maxVal/5, 0];
                    yLabelsLinear.forEach((label, i) => {
                        const y = PAD.T + (i / 5) * plotH;
                        ctx.fillText(Math.round(label), PAD.L - 5, y);
                    });
                }
            }

            function drawPeakLine(ctx, x, h, color, dashed = false) {
                const y0 = PAD.T, y1 = h - PAD.B;
                ctx.save();
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                if (dashed) ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y1); ctx.stroke();
                ctx.restore();
            }

            function drawGuide(ctx, x, h) {
                ctx.save();
                ctx.strokeStyle = 'rgba(96,165,250,.75)'; ctx.setLineDash([4, 4]);
                ctx.beginPath(); ctx.moveTo(x, PAD.T); ctx.lineTo(x, h - PAD.B); ctx.stroke();
                ctx.restore();
            }

            // ==== ‡∏ß‡∏≤‡∏î FFT ====
            function drawFFT() {
                const {width: w, height: h} = ctxFFT.canvas;
                drawBackground(ctxFFT);
                if (!freqArray) return;

                const N = freqArray.length;
                const fpb = sampleRate / (2 * N);

                // peak (current)
                let peakBin = 0, peakVal = -Infinity;
                for (let i = 0; i < N; i++) {
                    if (freqArray[i] > peakVal) {
                        peakVal = freqArray[i];
                        peakBin = i;
                    }
                }
                const peakFreqNow = peakBin * fpb;
                const peakDbNow = dbfs(freqArray[peakBin] || 0);
                peakEl.textContent = Math.round(peakFreqNow) + ' Hz';

                if (!peakArray || peakArray.length !== N) peakArray = new Uint8Array(N);
                if (holdEnabled) for (let i = 0; i < N; i++) peakArray[i] = Math.max(peakArray[i], freqArray[i]);

                // current (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß)
                ctxFFT.beginPath();
                let started = false;
                for (let i = 1; i < N; i++) {
                    const f = i * fpb;
                    if (f < 20) continue;
                    if (f > 20000) break;
                    const x = mapLogX(f, w);
                    const y = mapDbToY(dbfs(freqArray[i]), h);
                    if (!started) {
                        ctxFFT.moveTo(x, y);
                        started = true;
                    } else ctxFFT.lineTo(x, y);
                }
                ctxFFT.strokeStyle = FFT_COLOR;
                ctxFFT.lineWidth = 2;
                ctxFFT.stroke();

                // peak-hold (‡∏°‡πà‡∏ß‡∏á ‡∏à‡∏≤‡∏á)
                ctxFFT.beginPath();
                started = false;
                for (let i = 1; i < N; i++) {
                    const f = i * fpb;
                    if (f < 20) continue;
                    if (f > 20000) break;
                    const x = mapLogX(f, w);
                    const y = mapDbToY(dbfs(peakArray[i] || 0), h);
                    if (!started) {
                        ctxFFT.moveTo(x, y);
                        started = true;
                    } else ctxFFT.lineTo(x, y);
                }
                ctxFFT.save();
                ctxFFT.globalAlpha = 0.35;
                ctxFFT.strokeStyle = PEAK_COLOR;
                ctxFFT.lineWidth = 1.25;
                ctxFFT.stroke();
                ctxFFT.restore();

                // ‡πÄ‡∏™‡πâ‡∏ô‡∏û‡∏µ‡∏Ñ (current + hold)
                const xPeakNow = mapLogX(peakFreqNow, w);
                drawPeakLine(ctxFFT, xPeakNow, h, 'rgba(96,165,250,0.6)', false);
                let holdBin = 0, holdVal = 0;
                for (let i = 0; i < N; i++) {
                    if (peakArray[i] > holdVal) {
                        holdVal = peakArray[i];
                        holdBin = i;
                    }
                }
                if (holdVal > 0) {
                    drawPeakLine(ctxFFT, mapLogX(holdBin * fpb, w), h, 'rgba(250,204,21,0.55)', true);
                }

                // ‡∏õ‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏≤‡∏ô‡∏ô‡∏≠‡∏Å‡∏Å‡∏£‡∏≤‡∏ü
                fftPeakText.textContent = `Peak: ${fmtHz(peakFreqNow)} ‚Ä¢ ${peakDbNow.toFixed(1)} dBFS`;
                if (holdVal > 0) {
                    fftHoldText.style.display = '';
                    fftHoldText.textContent = `Hold: ${fmtHz(holdBin * fpb)} ‚Ä¢ ${dbfs(holdVal).toFixed(1)} dBFS`;
                } else {
                    fftHoldText.style.display = 'none';
                }

                if (guideFFT) {
                    drawGuide(ctxFFT, guideFFT.xPx, h);
                }
            }

            // ==== ‡∏ß‡∏≤‡∏î Octave ====
            function drawOctave() {
                const {width: w, height: h} = ctxOct.canvas;
                drawBackground(ctxOct, yAxisMode);
                if (!freqArray || !bands.length) return;

                const N = freqArray.length;
                const fpb = sampleRate / (2 * N);
                const maxValLinear = yAxisMode === 'linear-127' ? 127 : 255;

                const vals = bands.map(b => {
                    const s = Math.max(0, Math.floor(b.fl / fpb)), e = Math.min(N - 1, Math.ceil(b.fh / fpb));
                    let sum = 0, cnt = 0;
                    for (let i = s; i <= e; i++) {
                        sum += freqArray[i];
                        cnt++;
                    }
                    let v = cnt ? (sum / cnt) : 0;
                    if (aWeightChk.checked) v *= Math.pow(10, aWeighting(b.fc) / 20);
                    return v;
                });

                if (!peakOct || peakOct.length !== vals.length) peakOct = new Float32Array(vals.length);
                if (holdEnabled) for (let i = 0; i < vals.length; i++) peakOct[i] = Math.max(peakOct[i], vals[i]);

                // ‡πÅ‡∏ó‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß)
                ctxOct.fillStyle = BAR_COLOR;
                for (let i = 0; i < vals.length; i++) {
                    const b = bands[i];
                    const xL = mapLogX(b.fl, w), xR = mapLogX(b.fh, w);
                    const barW = Math.max(2, xR - xL - 2);
                    const y = yAxisMode === 'octave-db' ? mapDbToY(dbfs(vals[i]), h) : mapLinearToY(vals[i], h, maxValLinear);
                    const plotBottom = h - PAD.B;
                    const hh = (plotBottom - y);
                    ctxOct.fillRect(xL + 1, y, barW, Math.max(1, hh));
                }

                // ‡πÄ‡∏™‡πâ‡∏ô‡πÇ‡∏Æ‡∏•‡∏î‡πå‡πÅ‡∏ö‡∏ö‡∏à‡∏≤‡∏á
                ctxOct.beginPath();
                for (let i = 0; i < vals.length; i++) {
                    const cx = mapLogX(bands[i].fc, w);
                    const y = yAxisMode === 'octave-db' ? mapDbToY(dbfs(peakOct[i] || 0), h) : mapLinearToY(peakOct[i], h, maxValLinear);
                    if (i === 0) ctxOct.moveTo(cx, y);
                    else ctxOct.lineTo(cx, y);
                }
                ctxOct.save();
                ctxOct.globalAlpha = 0.45;
                ctxOct.strokeStyle = HOLD_COLOR;
                ctxOct.lineWidth = 1.5;
                ctxOct.stroke();
                ctxOct.restore();

                // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏û‡∏µ‡∏Ñ (current + hold)
                let idxNow = 0, vNow = -1;
                for (let i = 0; i < vals.length; i++) {
                    if (vals[i] > vNow) {
                        vNow = vals[i];
                        idxNow = i;
                    }
                }
                drawPeakLine(ctxOct, mapLogX(bands[idxNow].fc, w), h, 'rgba(96,165,250,0.6)', false);

                let idxHold = 0, vHold = 0;
                for (let i = 0; i < peakOct.length; i++) {
                    if (peakOct[i] > vHold) {
                        vHold = peakOct[i];
                        idxHold = i;
                    }
                }
                if (vHold > 0) {
                    drawPeakLine(ctxOct, mapLogX(bands[idxHold].fc, w), h, 'rgba(250,204,21,0.55)', true);
                }

                // ‡∏õ‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏≤‡∏ô‡∏ô‡∏≠‡∏Å‡∏Å‡∏£‡∏≤‡∏ü
                if (yAxisMode === 'octave-db') {
                    octPeakText.textContent = `Peak: ${fmtHz(bands[idxNow].fc)} ‚Ä¢ ${dbfs(vNow).toFixed(1)} dBFS`;
                    if (vHold > 0) {
                        octHoldText.style.display = '';
                        octHoldText.textContent = `Hold: ${fmtHz(bands[idxHold].fc)} ‚Ä¢ ${dbfs(vHold).toFixed(1)} dBFS`;
                    } else {
                        octHoldText.style.display = 'none';
                    }
                } else {
                    octPeakText.textContent = `Peak: ${fmtHz(bands[idxNow].fc)} ‚Ä¢ ${vNow.toFixed(1)}`;
                    if (vHold > 0) {
                        octHoldText.style.display = '';
                        octHoldText.textContent = `Hold: ${fmtHz(bands[idxHold].fc)} ‚Ä¢ ${vHold.toFixed(1)}`;
                    } else {
                        octHoldText.style.display = 'none';
                    }
                }

                if (guideOCT) {
                    drawGuide(ctxOct, guideOCT.xPx, h);
                }
            }

            // ‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏±‡∏ö‡∏ö‡∏ô Canvas
            function drawOverlayMessage(ctx, w, h) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.font = '24px system-ui';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Heatmap OFF', w / 2, h / 2);
            }

            // ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô Cursor ‡∏ó‡∏±‡∏ö‡∏ö‡∏ô Heatmap
            function drawHeatmapGuide(ctx, x, h) {
                ctx.save();
                ctx.strokeStyle = 'rgba(96,165,250,.75)';
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h - PAD.B);
                ctx.stroke();
                ctx.restore();
            }
            
            // ==== ‡∏ß‡∏≤‡∏î Heatmap ====
            function drawHeatmap() {
                const {width: w, height: h} = ctxHeatmap.canvas;
                const plotHeatmapH = h - PAD.B;

                if (!freqArray || !heatmapFreqBinMap) return;

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ñ‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ bins ‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß
                const currentData = heatmapFreqBinMap.map(bin => {
                    let sum = 0;
                    let count = 0;
                    for (let j = bin.binStart; j <= bin.binEnd; j++) {
                        sum += freqArray[j];
                        count++;
                    }
                    const avgDb = count > 0 ? dbfs(sum / count) : -100;
                    return { db: avgDb, fStart: bin.fStart, fEnd: bin.fEnd };
                });

                // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏≠‡∏≤‡πÄ‡∏£‡∏¢‡πå
                heatmapData.unshift(currentData);
                if (heatmapData.length > maxHeatmapData) {
                    heatmapData.pop();
                }

                // ‡∏ß‡∏≤‡∏î heatmap
                const timeScale = plotHeatmapH / maxHeatmapData;
                ctxHeatmap.clearRect(0, 0, w, h);
                for (let i = 0; i < heatmapData.length; i++) {
                    const y = i * timeScale;
                    const frameData = heatmapData[i];
                    for (let j = 0; j < frameData.length; j++) {
                        const { fStart, fEnd, db } = frameData[j];
                        const xL = mapLogX(fStart, w);
                        const xR = mapLogX(fEnd, w);
                        const barWidth = Math.max(1, xR - xL);

                        ctxHeatmap.fillStyle = mapDbToColor(db);
                        ctxHeatmap.fillRect(xL, y, barWidth, timeScale);
                    }
                }
                
                // ‡∏ß‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (‡∏Å‡∏£‡∏¥‡∏î‡πÅ‡∏•‡∏∞‡∏õ‡πâ‡∏≤‡∏¢‡∏Å‡∏≥‡∏Å‡∏±‡∏ö)
                ctxHeatmap.clearRect(0, plotHeatmapH, w, PAD.B); // Clear area for labels
                // ‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á log ticks
                ctxHeatmap.strokeStyle = GRID_V;
                const ticks = [20, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000, 2000, 4000, 8000, 16000];
                ticks.forEach(t => {
                    const x = mapLogX(t, w);
                    ctxHeatmap.beginPath(); ctxHeatmap.moveTo(x, 0); ctxHeatmap.lineTo(x, plotHeatmapH); ctxHeatmap.stroke();
                });
                ctxHeatmap.fillStyle = LABEL;
                ctxHeatmap.font = '12px system-ui';
                ctxHeatmap.textBaseline = 'alphabetic';
                [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000].forEach(t => {
                    const x = mapLogX(t, w);
                    ctxHeatmap.fillText(t >= 1000 ? (t / 1000) + 'k' : t, x - 8, h - LABEL_Y);
                });

                // ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô Cursor ‡∏ó‡∏±‡∏ö‡∏ö‡∏ô Heatmap ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏ï‡∏∞‡∏Ñ‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà
                if (guideHeatmap) {
                    drawHeatmapGuide(ctxHeatmap, guideHeatmap.xPx, h);
                }
            }

            // ==== RMS, MAX, AVG ====
            function updateMeters() {
                if (!dataArray) return;
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const v = (dataArray[i] - 128) / 128;
                    sum += v * v;
                }
                const rms = Math.sqrt(sum / dataArray.length);
                const db = 20 * Math.log10(rms + 1e-12);
                
                // Update RMS (‡∏î‡∏¥‡∏ö dBFS)
                rmsEl.textContent = db.toFixed(1) + ' dBFS';

                // Update MAX dB-A (‡πÉ‡∏ä‡πâ A-weighting ‡∏ó‡∏µ‡πà 1 kHz ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì)
                const aWeightedMax = maxDb + aWeighting(1000);
                maxDb = Math.max(maxDb, db);
                maxDbEl.textContent = aWeightedMax.toFixed(1) + ' dB-A';

                // Update AVG dB-A (‡πÉ‡∏ä‡πâ A-weighting ‡∏ó‡∏µ‡πà 1 kHz ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì)
                const aWeightedAvg = avgDb + aWeighting(1000);
                if (avgDb === -120) { // Initial state
                    avgDb = db;
                } else {
                    avgDb = avgAlpha * avgDb + (1 - avgAlpha) * db;
                }
                avgDbEl.textContent = aWeightedAvg.toFixed(1) + ' dB-A';
            }

            function loop() {
                if (!running) return;
                analyser.getByteTimeDomainData(dataArray);
                analyser.getByteFrequencyData(freqArray);
                if (avgChk.checked) {
                    if (!avgBuffer || avgBuffer.length !== freqArray.length) avgBuffer = new Float32Array(freqArray.length);
                    const alpha = 0.5;
                    for (let i = 0; i < freqArray.length; i++) {
                        avgBuffer[i] = alpha * avgBuffer[i] + (1 - alpha) * freqArray[i];
                        freqArray[i] = avgBuffer[i];
                    }
                }
                drawFFT();
                drawOctave();
                updateMeters();

                const now = performance.now();
                if (heatmapEnabled && (now - lastHeatmapUpdate >= HEATMAP_UPDATE_RATE_MS)) {
                    drawHeatmap();
                    lastHeatmapUpdate = now;
                } else if (!heatmapEnabled) {
                    // ‡∏ñ‡πâ‡∏≤ heatmap ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå canvas
                    ctxHeatmap.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
                    // ‡∏ß‡∏≤‡∏î background ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà
                    ctxHeatmap.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
                    drawBackground(ctxHeatmap);
                    drawOverlayMessage(ctxHeatmap, heatmapCanvas.width, heatmapCanvas.height);
                }

                rafId = requestAnimationFrame(loop);
            }

            async function start() {
                try {
                    btnStart.disabled = true;
                    btnStop.disabled = false;
                    const constraints = {
                        audio: {
                            echoCancellation: ec.checked ? false : true,
                            noiseSuppression: ns.checked ? false : true,
                            autoGainControl: agc.checked ? false : true,
                            // sampleRate: 48000
                        }
                    };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
                    sampleRate = audioCtx.sampleRate;
                    analyser = audioCtx.createAnalyser();
                    micSrc = audioCtx.createMediaStreamSource(stream);
                    micSrc.connect(analyser);

                    analyser.fftSize = parseInt(fftSel.value);
                    analyser.smoothingTimeConstant = parseFloat(smoothing.value);
                    analyser.minDecibels = -100;
                    analyser.maxDecibels = 0;

                    dataArray = new Uint8Array(analyser.fftSize);
                    freqArray = new Uint8Array(analyser.frequencyBinCount);
                    avgBuffer = null; // reset
                    peakArray = null;
                    peakOct = null;
                    heatmapData = [];
                    heatmapFreqBinMap = genHeatmapBins();

                    labelRate.textContent = `Sample Rate: ${sampleRate} Hz`;
                    bands = genBands(octN);
                    
                    running = true;
                    requestAnimationFrame(loop);

                    console.log('Audio measurement started. Sample Rate:', sampleRate);
                } catch(err) {
                    console.error('Error starting audio:', err);
                    btnStart.disabled = false;
                    btnStop.disabled = true;
                }
            }

            function stop() {
                running = false;
                if (rafId) cancelAnimationFrame(rafId);
                if (micSrc) micSrc.mediaStream.getTracks().forEach(track => track.stop());
                if (audioCtx) audioCtx.close().then(() => {
                    audioCtx = null;
                    micSrc = null;
                    analyser = null;
                    console.log('Audio measurement stopped.');
                });
                btnStart.disabled = false;
                btnStop.disabled = true;
            }

            function clearPeak() {
                if (peakArray) peakArray.fill(0);
                if (peakOct) peakOct.fill(0);
                fftHoldText.style.display = 'none';
                octHoldText.style.display = 'none';
            }

            function clearDbMeters() {
                maxDb = -120;
                avgDb = -120;
                maxDbEl.textContent = '‚Äî';
                avgDbEl.textContent = '‚Äî';
            }

            // Events
            btnStart.addEventListener('click', start);
            btnStop.addEventListener('click', stop);
            btnHold.addEventListener('click', () => {
                holdEnabled = !holdEnabled;
                btnHold.setAttribute('aria-pressed', holdEnabled);
                btnHold.textContent = `üìå Hold Peak: ${holdEnabled ? 'ON' : 'OFF'}`;
            });
            btnClear.addEventListener('click', clearPeak);
            btnClearDb.addEventListener('click', clearDbMeters);

            // ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            fftSel.addEventListener('change', () => {
                if (analyser) {
                    stop();
                    start();
                }
            });
            octResSel.addEventListener('change', () => {
                octN = parseInt(octResSel.value);
                bands = genBands(octN);
            });
            yAxisSel.addEventListener('change', () => {
                yAxisMode = yAxisSel.value;
                updateOctaveTitle();
            });

            // Heatmap toggle
            btnToggleHeatmap.addEventListener('click', () => {
                heatmapEnabled = !heatmapEnabled;
                btnToggleHeatmap.setAttribute('aria-pressed', heatmapEnabled);
                btnToggleHeatmap.textContent = `üî• Heatmap: ${heatmapEnabled ? 'ON' : 'OFF'}`;
                if (!heatmapEnabled) {
                    ctxHeatmap.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
                    drawOverlayMessage(ctxHeatmap, heatmapCanvas.width, heatmapCanvas.height);
                }
            });

            // Cursor for plots
            function setupCursorEvents(canvas, tipEl, plotType) {
                function showTip(e) {
                    if (!running) return;
                    const rect = canvas.getBoundingClientRect();
                    const xPx = e.clientX - rect.left;
                    const yPx = e.clientY - rect.top;

                    // check if inside plot area
                    if (xPx < PAD.L || xPx > rect.width - PAD.R || yPx < PAD.T || yPx > rect.height - PAD.B) {
                        tipEl.style.display = 'none';
                        return;
                    }

                    const freq = xToFreq(xPx, rect.width);
                    let tipText = `F: ${fmtHz(freq)}`;

                    if (plotType === 'FFT') {
                        const N = analyser.frequencyBinCount;
                        const fpb = sampleRate / (2 * N);
                        const bin = Math.round(freq / fpb);
                        if (bin >= 0 && bin < N) {
                            const db = dbfs(freqArray[bin]);
                            tipText += ` ‚Ä¢ ${db.toFixed(1)} dBFS`;
                        }
                    } else if (plotType === 'OCT') {
                        const band = bands.find(b => freq >= b.fl && freq <= b.fh);
                        if (band) {
                            tipText = `Center F: ${fmtHz(band.fc)}`;
                            const vals = bands.map(b => {
                                const s = Math.max(0, Math.floor(b.fl / (sampleRate / (2 * freqArray.length)))), e = Math.min(freqArray.length - 1, Math.ceil(b.fh / (sampleRate / (2 * freqArray.length))));
                                let sum = 0, cnt = 0;
                                for (let i = s; i <= e; i++) { sum += freqArray[i]; cnt++; }
                                return cnt ? (sum / cnt) : 0;
                            });
                            const idx = bands.indexOf(band);
                            const val = vals[idx];
                            if (yAxisMode === 'octave-db') {
                                tipText += ` ‚Ä¢ ${dbfs(val).toFixed(1)} dBFS`;
                            } else {
                                tipText += ` ‚Ä¢ ${val.toFixed(1)}`;
                            }
                        }
                    } else if (plotType === 'Heatmap') {
                        tipText += ` ‚Ä¢ (Heatmap)`;
                    }

                    tipEl.style.display = '';
                    tipEl.textContent = tipText;
                    let xPos = xPx;
                    let yPos = yPx;
                    if (yPx < rect.height / 2) yPos += tipEl.offsetHeight + 10;
                    tipEl.style.left = `${xPos}px`;
                    tipEl.style.top = `${yPos}px`;
                    
                    if (plotType === 'FFT') guideFFT = { xPx };
                    if (plotType === 'OCT') guideOCT = { xPx };
                    if (plotType === 'Heatmap') guideHeatmap = { xPx };
                    
                    // Force redraw for guides
                    if (running) {
                        drawFFT();
                        drawOctave();
                        if (heatmapEnabled) drawHeatmap();
                    }
                }

                function hideTip() {
                    tipEl.style.display = 'none';
                    if (plotType === 'FFT') guideFFT = null;
                    if (plotType === 'OCT') guideOCT = null;
                    if (plotType === 'Heatmap') guideHeatmap = null;
                    
                    // Force redraw to remove guides
                    if (running) {
                        drawFFT();
                        drawOctave();
                        if (heatmapEnabled) drawHeatmap();
                    }
                }

                canvas.addEventListener('mousemove', showTip);
                canvas.addEventListener('mouseleave', hideTip);
                canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    showTip(touch);
                });
                canvas.addEventListener('touchend', hideTip);
                canvas.addEventListener('touchcancel', hideTip);
            }

            setupCursorEvents(fftCanvas, fftTip, 'FFT');
            setupCursorEvents(octCanvas, octTip, 'OCT');
            setupCursorEvents(heatmapCanvas, heatmapTip, 'Heatmap');

            // Initial drawing
            drawBackground(ctxFFT);
            drawBackground(ctxOct, yAxisMode);
            drawBackground(ctxHeatmap);
        })();
    </script>
</body>
</html>
